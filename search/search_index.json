{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dans-module-archetype \u00b6 Generate a skeleton DANS Module. SYNOPSIS \u00b6 generate-dans-module.sh DESCRIPTION \u00b6 Creates a DANS module based on DropWizard . It uses the maven archetype plugin . ARGUMENTS \u00b6 The generate-dans-module.sh script will interactively query you for argument values. EXAMPLES \u00b6 This assumes that you have copied the generate-dans-module.sh script to a directory that is on your $PATH . On the Mac that could be /usr/local/bin cd ~/git/test/ generate-dans-module.sh dans-module-archetype version? (default = 0.0.1-SNAPSHOT): Module artifactId: dans-test-module Name module's main package (i.e. the one UNDER nl.knaw.dans): test Description (one to four sentences): This is a test module [INFO] Scanning for projects... [INFO] [INFO] ------------------< org.apache.maven:standalone-pom >------------------- [INFO] Building Maven Stub Project (No POM) 1 [INFO] --------------------------------[ pom ]--------------------------------- [INFO] [INFO] >>> maven-archetype-plugin:3.1.2:generate (default-cli) > generate-sources @ standalone-pom >>> [INFO] [INFO] <<< maven-archetype-plugin:3.1.2:generate (default-cli) < generate-sources @ standalone-pom <<< [INFO] [INFO] [INFO] --- maven-archetype-plugin:3.1.2:generate (default-cli) @ standalone-pom --- [INFO] Generating project in Interactive mode [INFO] Archetype repository not defined. Using the one from [nl.knaw.dans:dans-module-archetype:0.0.1-SNAPSHOT] found in catalog local [INFO] Using property: groupId = nl.knaw.dans [INFO] Using property: artifactId = dans-test-module [INFO] Using property: version = 0.0.1-SNAPSHOT [INFO] Using property: package = nl.knaw.dans.test [INFO] Using property: description = This is a test module [INFO] Using property: inceptionYear = 2021 [INFO] Using property: javaName = DansTestModule [INFO] Using property: moduleSubpackage = test [INFO] Using property: projectName = Dans Test Module Confirm properties configuration: groupId: nl.knaw.dans artifactId: dans-test-module version: 0.0.1-SNAPSHOT package: nl.knaw.dans.test description: This is a test module inceptionYear: 2021 javaName: DansTestModule moduleSubpackage: test projectName: Dans Test Module Y: : Now hit Enter to accept these settings and the module will be generated and built for the first time. INSTALLATION AND CONFIGURATION \u00b6 Add https://maven.dans.knaw.nl/releases/ as a plug-in repository if you want to use a released version of this archetype. Clone and build the project if you want to use a snapshot. DEVELOPMENT \u00b6 Building from source \u00b6 Prerequisites: Maven 3.3.3 or higher Steps: git clone https://github.com/DANS-KNAW/dans-module-archetype.git cd dans-module-archetype mvn install","title":"Manual"},{"location":"#dans-module-archetype","text":"Generate a skeleton DANS Module.","title":"dans-module-archetype"},{"location":"#synopsis","text":"generate-dans-module.sh","title":"SYNOPSIS"},{"location":"#description","text":"Creates a DANS module based on DropWizard . It uses the maven archetype plugin .","title":"DESCRIPTION"},{"location":"#arguments","text":"The generate-dans-module.sh script will interactively query you for argument values.","title":"ARGUMENTS"},{"location":"#examples","text":"This assumes that you have copied the generate-dans-module.sh script to a directory that is on your $PATH . On the Mac that could be /usr/local/bin cd ~/git/test/ generate-dans-module.sh dans-module-archetype version? (default = 0.0.1-SNAPSHOT): Module artifactId: dans-test-module Name module's main package (i.e. the one UNDER nl.knaw.dans): test Description (one to four sentences): This is a test module [INFO] Scanning for projects... [INFO] [INFO] ------------------< org.apache.maven:standalone-pom >------------------- [INFO] Building Maven Stub Project (No POM) 1 [INFO] --------------------------------[ pom ]--------------------------------- [INFO] [INFO] >>> maven-archetype-plugin:3.1.2:generate (default-cli) > generate-sources @ standalone-pom >>> [INFO] [INFO] <<< maven-archetype-plugin:3.1.2:generate (default-cli) < generate-sources @ standalone-pom <<< [INFO] [INFO] [INFO] --- maven-archetype-plugin:3.1.2:generate (default-cli) @ standalone-pom --- [INFO] Generating project in Interactive mode [INFO] Archetype repository not defined. Using the one from [nl.knaw.dans:dans-module-archetype:0.0.1-SNAPSHOT] found in catalog local [INFO] Using property: groupId = nl.knaw.dans [INFO] Using property: artifactId = dans-test-module [INFO] Using property: version = 0.0.1-SNAPSHOT [INFO] Using property: package = nl.knaw.dans.test [INFO] Using property: description = This is a test module [INFO] Using property: inceptionYear = 2021 [INFO] Using property: javaName = DansTestModule [INFO] Using property: moduleSubpackage = test [INFO] Using property: projectName = Dans Test Module Confirm properties configuration: groupId: nl.knaw.dans artifactId: dans-test-module version: 0.0.1-SNAPSHOT package: nl.knaw.dans.test description: This is a test module inceptionYear: 2021 javaName: DansTestModule moduleSubpackage: test projectName: Dans Test Module Y: : Now hit Enter to accept these settings and the module will be generated and built for the first time.","title":"EXAMPLES"},{"location":"#installation-and-configuration","text":"Add https://maven.dans.knaw.nl/releases/ as a plug-in repository if you want to use a released version of this archetype. Clone and build the project if you want to use a snapshot.","title":"INSTALLATION AND CONFIGURATION"},{"location":"#development","text":"","title":"DEVELOPMENT"},{"location":"#building-from-source","text":"Prerequisites: Maven 3.3.3 or higher Steps: git clone https://github.com/DANS-KNAW/dans-module-archetype.git cd dans-module-archetype mvn install","title":"Building from source"},{"location":"arch/","text":"DANS Data Station Architecture \u00b6 This module is a component in the DANS Data Station Architecture .","title":"\u21d2 DANS Data Station Architecture"},{"location":"arch/#dans-data-station-architecture","text":"This module is a component in the DANS Data Station Architecture .","title":"DANS Data Station Architecture"},{"location":"common-practices/","text":"Coding Practices \u00b6 Code Style \u00b6 Install the IntelliJ code style and inspections . Format the source code with these settings in our own projects. Resolve the warnings indicated by the inspections. In Dataverse try to minimize code changes due to reformatting, so only apply formatting to code that you have changed anyway. In the POM file keep the order the of the elements as follows (note that some are optional): modelVersion parent groupId artifactId version name url description inceptionYear properties scm dependencyManagement dependencies build repositories distributionManagement profiles Lombok \u00b6 Use Lombok for: Adding loggers with the @Slf4j annotation (this names the logger after the fully qualified class name automatically). Creating getters, setters and constructors on value objects (i.e. the main purpose of the object is to store values and not to perform operations). Dependency Management \u00b6 Dependency management of Java projects is done with Maven. Projects should inherit from dans-dropwizard-project . The first thing that most projects will include is io.dropwizard:dropwizard-core . Testing \u00b6 Unit test names should be as descriptive as possible. Since this will often involve creating long test names, use snake_case instead of camelCase here. Unit tests will often need to write some temporary data to disk. The location for this is <project-dir>/target/test/<ClassNameOfUnitTest> . By working under target we make sure the unit tests don't interfere with the project itself or the test files we are using for debugging . Unit tests should clear their temporary directory before the tests start, but leave everything on disk after finishing. This allows you to diagnose any problems with a test by running it and inspecting its temporary directory. Debugging \u00b6 For debugging use the scripts in dans-core-systems (only available for members of the DANS-KNAW organization). Start the program with the start-*debug.sh helper scripts and then attach IntelliJ to the VM. When debugging you will often want to use temporary test data or configure certain directories for the application under test to use. This is the purpose of the <project-dir>/data folder. Packaging and Installation \u00b6 Documentation \u00b6 Each module has its associated documentation site, which is published at dans-knaw.github.io. The archetype sets up the project with a skeleton site. Use the start-mkdocs.sh script in dans-core-systems to start the site locally and see what it looks like after you have made your changes. Each documentation site follows a standard lay-out and includes the following: index.md , including these sections: SYNOPSIS - overview of the main command line usage DESCRIPTION - most of your docs should go here ARGUMENTS - a copy of the command line help EXAMPLES (optional) - if relevant INSTALLATION AND CONFIGURATION - boilerplate text about how to install and configure. The configuration settings should be documented not here, but in comments in the configuration file. BUILDING FROM SOURCE - boilerplate text about how to build the project dev.md (optional) - documentation that is only relevant for developers of this module. More pages can be added. In general start by adding documentation to the DESCRIPTION section of index.md . At the point where index.md is becoming very large you may start moving the fine print to separate pages and link to those from the DESCRIPTION section. JavaDocs \u00b6 If the project is a library it should include JavaDocs. Extensive code examples are best relegated to separated pages, outside the JavaDocs, so that you can make full use of the extended Markdown support of mkdocs. You can then link to those from the JavaDocs.","title":"Common Practices"},{"location":"common-practices/#coding-practices","text":"","title":"Coding Practices"},{"location":"common-practices/#code-style","text":"Install the IntelliJ code style and inspections . Format the source code with these settings in our own projects. Resolve the warnings indicated by the inspections. In Dataverse try to minimize code changes due to reformatting, so only apply formatting to code that you have changed anyway. In the POM file keep the order the of the elements as follows (note that some are optional): modelVersion parent groupId artifactId version name url description inceptionYear properties scm dependencyManagement dependencies build repositories distributionManagement profiles","title":"Code Style"},{"location":"common-practices/#lombok","text":"Use Lombok for: Adding loggers with the @Slf4j annotation (this names the logger after the fully qualified class name automatically). Creating getters, setters and constructors on value objects (i.e. the main purpose of the object is to store values and not to perform operations).","title":"Lombok"},{"location":"common-practices/#dependency-management","text":"Dependency management of Java projects is done with Maven. Projects should inherit from dans-dropwizard-project . The first thing that most projects will include is io.dropwizard:dropwizard-core .","title":"Dependency Management"},{"location":"common-practices/#testing","text":"Unit test names should be as descriptive as possible. Since this will often involve creating long test names, use snake_case instead of camelCase here. Unit tests will often need to write some temporary data to disk. The location for this is <project-dir>/target/test/<ClassNameOfUnitTest> . By working under target we make sure the unit tests don't interfere with the project itself or the test files we are using for debugging . Unit tests should clear their temporary directory before the tests start, but leave everything on disk after finishing. This allows you to diagnose any problems with a test by running it and inspecting its temporary directory.","title":"Testing"},{"location":"common-practices/#debugging","text":"For debugging use the scripts in dans-core-systems (only available for members of the DANS-KNAW organization). Start the program with the start-*debug.sh helper scripts and then attach IntelliJ to the VM. When debugging you will often want to use temporary test data or configure certain directories for the application under test to use. This is the purpose of the <project-dir>/data folder.","title":"Debugging"},{"location":"common-practices/#packaging-and-installation","text":"","title":"Packaging and Installation"},{"location":"common-practices/#documentation","text":"Each module has its associated documentation site, which is published at dans-knaw.github.io. The archetype sets up the project with a skeleton site. Use the start-mkdocs.sh script in dans-core-systems to start the site locally and see what it looks like after you have made your changes. Each documentation site follows a standard lay-out and includes the following: index.md , including these sections: SYNOPSIS - overview of the main command line usage DESCRIPTION - most of your docs should go here ARGUMENTS - a copy of the command line help EXAMPLES (optional) - if relevant INSTALLATION AND CONFIGURATION - boilerplate text about how to install and configure. The configuration settings should be documented not here, but in comments in the configuration file. BUILDING FROM SOURCE - boilerplate text about how to build the project dev.md (optional) - documentation that is only relevant for developers of this module. More pages can be added. In general start by adding documentation to the DESCRIPTION section of index.md . At the point where index.md is becoming very large you may start moving the fine print to separate pages and link to those from the DESCRIPTION section.","title":"Documentation"},{"location":"common-practices/#javadocs","text":"If the project is a library it should include JavaDocs. Extensive code examples are best relegated to separated pages, outside the JavaDocs, so that you can make full use of the extended Markdown support of mkdocs. You can then link to those from the JavaDocs.","title":"JavaDocs"},{"location":"dans-module-design/","text":"DANS module design \u00b6 This document describes the design of a DANS module. By following a standard design and coding style we hope to make it easier for developers to understand each other's code and to make it easier to maintain and extend the code. The design builds on the Dropwizard conventions but go beyond that, filling in the blanks where Dropwizard is silent and adding some extra conventions that are specific to DANS. Project structure \u00b6 Projects use the standard Maven project structure. The main source code is in src/main/java , the test code in src/test/java . The main resources are in src/main/resources , the test resources in src/test/resources . The pom.xml file is in the root of the project. DANS specific additions are documented in the table below. Directory Description data/ Contains data files that are used for testing and debugging. Ignored by Git. docs/ Contains static files for the documentation site. etc/ Contains configuration files for local testing. Ignored by Git. src/main/assembly/dist Contains static files that are used in the creation of the (RPM) distribution package. src/main/rpm RPM scriplets. (Normally, these do not need to be modified.) src/test/resources/debug-etc Contains a version of the configuration files that is geared towards debugging locally. src/test/resources/test-etc (Optional) contains one of more versions of the configurtion files used in unit testing. Java packages \u00b6 The main package of a module is nl.knaw.dans.<module-name> , where <module-name> is the name of the module in lowercase, sometimes shortened a bit. Under this main package we use the Dropwizard convention with one addition: the classes that capture the configuration settings of the module are in the nl.knaw.dans.<module-name>.config package. Although Dropwizard does document the intended use of each package the documentation is not very detailed. The table below describes the intended use of each package in more detail. Package name Description api Generated DTO classes . client Client classes for external services. config Configuration classes. core The core functionality of the module, including domain classes, some of which may be database entities. db Data Access Object (DAO) classes. health Health check classes. resources Implementations of the microservices HTTP API endpoints views View classes for rendering an html UI based on a template (present in some Dropwizard examples). The core package is the most important one. It contains the domain classes and the business logic. The other packages are there to support the core . The core package may contain a services subpackage which contains classes that implement other supporting services. See the section below on Services for more information. db should only contain DAO classes. These classes should be as simple as possible. They should not contain any business logic. Basically, DAOs are just a thin layer on top of the database that deal with finding, creating, updating and deleting entities. Typical methods on a DAO are findById , findAll , create , update and delete . Database entities are simply domain classes that are persisted in the database. They are annotated with JPA annotations so that they can be persisted by the DAO classes. The DAO classes are responsible for creating, updating and deleting entities. Entities are located in the core package because they define domain concepts. The resources package contains the implementation of HTTP endpoints, both API and UI (if present). The API receives and sends back DTOs. Resources should also not implement business logic. The views package contains the classes that render the UI. They are called from the resources and use templates to render the UI. This way of creating a UI is called server-side rendering. The alternative is to use a JavaScript framework to render the UI on the client side. This is called client-side rendering. We will probably use server-side rendering only for very simple UIs. Generated classes \u00b6 A number of classes are generated from the OpenAPI specification of the module's API, which is defined in a separate project called <module-name>-api . If the microservice calls other microservices, the client code for those microservices is also generated, if possible. Generated code is not part of the code base, but is generated during the build process. The generated code is located under the target directory ( in target/generated-sources/openapi ). Data Transfer Object (DTO) classes \u00b6 DTO classes define the messages that are sent to and from the microservice. They are usually serialized to and from JSON. The DTO classes for the microservice are in the nl.knaw.dans.<module-name>.api package. The DTO classes for the client classes are in the nl.knaw.dans.<client-module-name>.client.api package. Resource interfaces \u00b6 Resource interfaces define the API endpoints of the microservice. They must be implemented by the resource classes. Both live in the same package namely nl.knaw.dans.<module-name>.resources . However, the resource interfaces are generated from the OpenAPI specification and therefore their source files are located under target/generated-sources/openapi/ (and not src/main/java ). Client classes \u00b6 Client classes allow the microservice to call other microservices without having to deal with the details of the HTTP protocol. The generated client code provides the same DTOs and basically the same resource classes as the microservice itself. The client classes are located in the nl.knaw.dans.<client-module-name>.client . In order to stress the correspondence between the client and the microservice subpackage names are the same: api - DTO classes resources - API endpoints In some cases it makes sense to define a handwritten client class in src/main/java/<client-module-name>/client . For example, if the client class needs to do some extra processing on the DTOs before sending them to the microservice. Another reason could be to provide a fa\u00e7ade for a number of endpoints. Services \u00b6 Services are classes that implement some supporting functionality that is used by the core of the module. This functionality is usually a bit more generic than the rest of the core. The service class serves to isolate the core from the details of the implementation of the service. For example, a service may implement the functionality to send an email. The core may use this service to send an email message to a user, but it does not need to know how the email is sent. This also makes it easier to unit-test the main core classes, because the service can be mocked. That said, the boundary between the core and the services is not always clear-cut. That is why the services are located in the nl.knaw.dans.<module-name>.core.services . This makes it clear that these classes are part of the core, but not the main core classes. The classes in services should from time to time be reviewed to see if they can be moved to a separate library. It is a good practise to define an interface for each service and to use that interface in the core classes. This makes it easier to move the service to a separate library later on. Typical services are: reading XML files, sending emails, managing a task queue, etc. In essence, the classes in client and db are also services. However, because they are more clearly separate from the core, they are not located in the core.services package. Application and configuration \u00b6 The application class is located in the nl.knaw.dans.<module-name> package. It is called <Module-name>Application and extends io.dropwizard.core.Application . Its purpose is to initialize the application. This means it will create all the bits and pieces that are needed to run the application and connect them together. It should not do anything else. The configuration class is located in the nl.knaw.dans.<module-name>.config It is called <Module-name>Config and extends io.dropwizard.Configuration . The configuration is serialized as YAML and is used to configure the application. It is a tree structure with every level corresponding to a bean class with a name that ends with Config . Since this can amount to a lot of classes, the configuration is usually split up in multiple files, and the helper files should also be located in the nl.knaw.dans.<module-name>.config package. API definition \u00b6 The API is defined in an OpenAPI file. The file is located in a separate project called <module-name>-api . The reason why the API is defined in a separate project is that is can be distributed as a Maven artifact. This allows other projects to use the API definition to generate client code for the microservice. The API project is very simple and serves only to create a JAR file with the OpenAPI file in it. A skeleton for the API project can be created with the DANS API archetype . Command line interface \u00b6 Most services will have a command line interface (CLI) that an administrator can use to issue commands to the service. To generate a CLI project use DANS CLI archetype .","title":"Module design"},{"location":"dans-module-design/#dans-module-design","text":"This document describes the design of a DANS module. By following a standard design and coding style we hope to make it easier for developers to understand each other's code and to make it easier to maintain and extend the code. The design builds on the Dropwizard conventions but go beyond that, filling in the blanks where Dropwizard is silent and adding some extra conventions that are specific to DANS.","title":"DANS module design"},{"location":"dans-module-design/#project-structure","text":"Projects use the standard Maven project structure. The main source code is in src/main/java , the test code in src/test/java . The main resources are in src/main/resources , the test resources in src/test/resources . The pom.xml file is in the root of the project. DANS specific additions are documented in the table below. Directory Description data/ Contains data files that are used for testing and debugging. Ignored by Git. docs/ Contains static files for the documentation site. etc/ Contains configuration files for local testing. Ignored by Git. src/main/assembly/dist Contains static files that are used in the creation of the (RPM) distribution package. src/main/rpm RPM scriplets. (Normally, these do not need to be modified.) src/test/resources/debug-etc Contains a version of the configuration files that is geared towards debugging locally. src/test/resources/test-etc (Optional) contains one of more versions of the configurtion files used in unit testing.","title":"Project structure"},{"location":"dans-module-design/#java-packages","text":"The main package of a module is nl.knaw.dans.<module-name> , where <module-name> is the name of the module in lowercase, sometimes shortened a bit. Under this main package we use the Dropwizard convention with one addition: the classes that capture the configuration settings of the module are in the nl.knaw.dans.<module-name>.config package. Although Dropwizard does document the intended use of each package the documentation is not very detailed. The table below describes the intended use of each package in more detail. Package name Description api Generated DTO classes . client Client classes for external services. config Configuration classes. core The core functionality of the module, including domain classes, some of which may be database entities. db Data Access Object (DAO) classes. health Health check classes. resources Implementations of the microservices HTTP API endpoints views View classes for rendering an html UI based on a template (present in some Dropwizard examples). The core package is the most important one. It contains the domain classes and the business logic. The other packages are there to support the core . The core package may contain a services subpackage which contains classes that implement other supporting services. See the section below on Services for more information. db should only contain DAO classes. These classes should be as simple as possible. They should not contain any business logic. Basically, DAOs are just a thin layer on top of the database that deal with finding, creating, updating and deleting entities. Typical methods on a DAO are findById , findAll , create , update and delete . Database entities are simply domain classes that are persisted in the database. They are annotated with JPA annotations so that they can be persisted by the DAO classes. The DAO classes are responsible for creating, updating and deleting entities. Entities are located in the core package because they define domain concepts. The resources package contains the implementation of HTTP endpoints, both API and UI (if present). The API receives and sends back DTOs. Resources should also not implement business logic. The views package contains the classes that render the UI. They are called from the resources and use templates to render the UI. This way of creating a UI is called server-side rendering. The alternative is to use a JavaScript framework to render the UI on the client side. This is called client-side rendering. We will probably use server-side rendering only for very simple UIs.","title":"Java packages"},{"location":"dans-module-design/#generated-classes","text":"A number of classes are generated from the OpenAPI specification of the module's API, which is defined in a separate project called <module-name>-api . If the microservice calls other microservices, the client code for those microservices is also generated, if possible. Generated code is not part of the code base, but is generated during the build process. The generated code is located under the target directory ( in target/generated-sources/openapi ).","title":"Generated classes"},{"location":"dans-module-design/#data-transfer-object-dto-classes","text":"DTO classes define the messages that are sent to and from the microservice. They are usually serialized to and from JSON. The DTO classes for the microservice are in the nl.knaw.dans.<module-name>.api package. The DTO classes for the client classes are in the nl.knaw.dans.<client-module-name>.client.api package.","title":"Data Transfer Object (DTO) classes"},{"location":"dans-module-design/#resource-interfaces","text":"Resource interfaces define the API endpoints of the microservice. They must be implemented by the resource classes. Both live in the same package namely nl.knaw.dans.<module-name>.resources . However, the resource interfaces are generated from the OpenAPI specification and therefore their source files are located under target/generated-sources/openapi/ (and not src/main/java ).","title":"Resource interfaces"},{"location":"dans-module-design/#client-classes","text":"Client classes allow the microservice to call other microservices without having to deal with the details of the HTTP protocol. The generated client code provides the same DTOs and basically the same resource classes as the microservice itself. The client classes are located in the nl.knaw.dans.<client-module-name>.client . In order to stress the correspondence between the client and the microservice subpackage names are the same: api - DTO classes resources - API endpoints In some cases it makes sense to define a handwritten client class in src/main/java/<client-module-name>/client . For example, if the client class needs to do some extra processing on the DTOs before sending them to the microservice. Another reason could be to provide a fa\u00e7ade for a number of endpoints.","title":"Client classes"},{"location":"dans-module-design/#services","text":"Services are classes that implement some supporting functionality that is used by the core of the module. This functionality is usually a bit more generic than the rest of the core. The service class serves to isolate the core from the details of the implementation of the service. For example, a service may implement the functionality to send an email. The core may use this service to send an email message to a user, but it does not need to know how the email is sent. This also makes it easier to unit-test the main core classes, because the service can be mocked. That said, the boundary between the core and the services is not always clear-cut. That is why the services are located in the nl.knaw.dans.<module-name>.core.services . This makes it clear that these classes are part of the core, but not the main core classes. The classes in services should from time to time be reviewed to see if they can be moved to a separate library. It is a good practise to define an interface for each service and to use that interface in the core classes. This makes it easier to move the service to a separate library later on. Typical services are: reading XML files, sending emails, managing a task queue, etc. In essence, the classes in client and db are also services. However, because they are more clearly separate from the core, they are not located in the core.services package.","title":"Services"},{"location":"dans-module-design/#application-and-configuration","text":"The application class is located in the nl.knaw.dans.<module-name> package. It is called <Module-name>Application and extends io.dropwizard.core.Application . Its purpose is to initialize the application. This means it will create all the bits and pieces that are needed to run the application and connect them together. It should not do anything else. The configuration class is located in the nl.knaw.dans.<module-name>.config It is called <Module-name>Config and extends io.dropwizard.Configuration . The configuration is serialized as YAML and is used to configure the application. It is a tree structure with every level corresponding to a bean class with a name that ends with Config . Since this can amount to a lot of classes, the configuration is usually split up in multiple files, and the helper files should also be located in the nl.knaw.dans.<module-name>.config package.","title":"Application and configuration"},{"location":"dans-module-design/#api-definition","text":"The API is defined in an OpenAPI file. The file is located in a separate project called <module-name>-api . The reason why the API is defined in a separate project is that is can be distributed as a Maven artifact. This allows other projects to use the API definition to generate client code for the microservice. The API project is very simple and serves only to create a JAR file with the OpenAPI file in it. A skeleton for the API project can be created with the DANS API archetype .","title":"API definition"},{"location":"dans-module-design/#command-line-interface","text":"Most services will have a command line interface (CLI) that an administrator can use to issue commands to the service. To generate a CLI project use DANS CLI archetype .","title":"Command line interface"}]}